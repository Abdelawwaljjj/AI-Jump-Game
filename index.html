<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>City Jump</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background-color: #000;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
        }

        .parallax-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('background.png') repeat;
            background-size: cover;
            z-index: -2;
            animation: parallaxScroll 20s linear infinite;
        }

        @keyframes parallaxScroll {
            from {
                background-position: 0 0;
            }
            to {
                background-position: -1000px 0;
            }
        }

        .menu {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100%;
            flex-direction: column;
            text-align: center;
            z-index: 1;
        }

        .menu-content {
            background-color: rgba(0, 0, 0, 0.7);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.6);
            max-width: 90%;
            width: 350px;
        }

        .title {
            font-size: 50px;
            margin-bottom: 30px;
            color: #ffdd59;
            text-shadow: 0 0 20px rgba(255, 221, 89, 0.7), 0 0 30px rgba(255, 221, 89, 0.5);
            animation: fadeIn 1.5s ease-out;
        }

        @keyframes fadeIn {
            0% { opacity: 0; transform: translateY(-20px); }
            100% { opacity: 1; transform: translateY(0); }
        }

        .neon-button {
            width: 100%;
            padding: 15px;
            margin: 15px 0;
            font-size: 22px;
            cursor: pointer;
            background: #111;
            color: white;
            border: none;
            border-radius: 5px;
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
            transition: color 0.3s;
            overflow: hidden;
        }

        .neon-button:before, .neon-button:after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.1);
            transition: opacity 0.3s;
        }

        .neon-button:before {
            opacity: 0;
            transform: scale(1.5);
        }

        .neon-button:hover:before {
            opacity: 1;
            transform: scale(1);
        }

        .neon-button:after {
            background: rgba(255, 255, 255, 0.2);
            opacity: 0;
            transform: scale(1.2);
        }

        .neon-button:hover:after {
            opacity: 1;
            transform: scale(1);
        }

        .neon-button:hover {
            color: #ff5733;
            box-shadow: 0 0 15px rgba(255, 87, 51, 0.5), 0 0 30px rgba(255, 87, 51, 0.3);
            text-shadow: 0 0 5px rgba(255, 87, 51, 0.8), 0 0 10px rgba(255, 87, 51, 0.6);
        }

        .chat-bar {
            background-color: black;
            color: white;
            font-weight: bold;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid white;
            position: fixed;
            width: 90%;
            max-width: 600px;
            box-sizing: border-box;
            z-index: 10;
            overflow-y: auto;
            max-height: 80%;
        }

        #instructionBar {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        #exitMessage {
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            text-align: center;
        }

        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 20px;
            height: 20px;
            background-color: red;
            border-radius: 50%;
            color: white;
            text-align: center;
            line-height: 18px;
            cursor: pointer;
            font-weight: bold;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
            z-index: 0;
        }

        #introVideo {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            background-color: black;
            display: none;
        }
    </style>
</head>
<body>
    <div class="parallax-bg"></div>
    <div id="mainMenu" class="menu">
        <div class="menu-content">
            <h1 class="title">City Jump</h1>
            <button id="startGameButton" class="menu-button neon-button">Start Game</button>
            <button id="instructionsButton" class="menu-button neon-button">Instructions</button>
            <button id="exitButton" class="menu-button neon-button">Exit</button>

            <div id="instructionBar" class="chat-bar">
                <div class="close-btn" onclick="closeInstructionBar()">x</div>
                <p>In City Jump, your goal is to collect as many coins as possible without falling into the lava. The longer you run, the faster your character will become, making it harder to land on platforms.</p>
                <p><strong>Master the basic controls:</strong><br>
                The character will automatically run forward. Your task is to jump at the right time by tapping the screen. Each tap will make your character jump.</p>
                <p><strong>Jump on platforms and avoid falling into the lava:</strong><br>
                Tap the screen to jump in time and avoid falling into the lava.</p>
                <p><strong>Adjust your speed:</strong><br>
                The longer you play, the faster your character will start to run. This means you will have to react faster to approaching platforms. Stay focused and adjust your timing to the increasing speed.</p>
                <p><strong>Collect coins while running:</strong><br>
                Along your path, there are gold coins that you can collect for extra points. Try to collect as many coins as possible while jumping to improve your record.</p>
                <p><strong>Avoid mistakes:</strong><br>
                Falling into the lava means the end of the game. It is important to stay focused and perfect your timing as the speed increases.</p>
                <p><strong>Stay in the game as long as possible:</strong><br>
                The longer you keep running to collect coins without making a mistake, the higher your score will be. Always try to break your personal record by collecting more coins.</p>
                <p><strong>Check your score:</strong><br>
                At the end of each round, your score is calculated based on the number of coins collected. This score is displayed on the screen so you can see how well you performed.</p>
                <p><strong>Play again and improve your score:</strong><br>
                Press the "Restart" button to start a new attempt. Use what you have learned to perform even better and improve your score.</p>
                <p><strong>Challenges and achievements:</strong><br>
                Try to complete different challenges and goals such as collecting a certain number of coins. This makes the game even more fun and challenging.</p>
                <p>Follow these steps and keep practicing to get better and better at City Jump. Have fun and good luck breaking your records!</p>
            </div>

            <!-- Exit Message -->
            <div id="exitMessage" class="chat-bar">
                <div class="close-btn" onclick="closeExitMessage()">x</div>
                Exit functionality is not supported on this platform. Close the app manually.
            </div>
        </div>
    </div>
    
    <video id="introVideo" src="intro-video.mp4"></video>
    <canvas id="gameCanvas"></canvas>
    
    <audio id="backgroundMusic" loop>
        <source src="background-music.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const mainMenu = document.getElementById('mainMenu');
        const startGameButton = document.getElementById('startGameButton');
        const instructionsButton = document.getElementById('instructionsButton');
        const exitButton = document.getElementById('exitButton');
        const backgroundMusic = document.getElementById('backgroundMusic');
        const introVideo = document.getElementById('introVideo');

        const instructionBar = document.getElementById('instructionBar');
        const exitMessage = document.getElementById('exitMessage');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        let gameOver = false;
        let highScore = 0;
        let backgroundImage = new Image();
        let animationFrame = 0;
        let characterImage1 = new Image();
        let characterImage2 = new Image();
        let floorImage = new Image();
        let explosionImage = new Image();

        function loadAssets(callback) {
          backgroundImage.src = 'gamebackground2.png';
          backgroundImage.onload = function () {
            characterImage1.src = 'character1.png';
            characterImage1.onload = function () {
              characterImage2.src = 'character2.png';
              characterImage2.onload = function () {
                floorImage.src = 'lavafloor.png';
                floorImage.onload = function () {
                  explosionImage.src = 'T-fireexplosion.png';
                  explosionImage.onload = function () {
                    callback();
                  };
                };
              };
            };
          };
        }

        const camera = {
          x: 0,
          y: 0,
          width: canvas.width,
          height: canvas.height,
          update: function() {
            this.x = player.x - this.width / 2;
            if (this.x < 0) {
              this.x = 0;
            }
          },
        };

        const player = {
          x: 50,
          y: canvas.height - 150 - 50,
          width: 30,
          height: 50,
          velocityX: 0,
          velocityY: 0,
          isJumping: false,
          speed: 4,
          jumpHeight: 14,
          score: 0,
          currentImage: null,
          explosionCounter: 0,
        };

        function setPlayerPositionOnPlatform(platform) {
          player.x = platform.x;
          player.y = platform.y - player.height;
        }

        class Platform {
          constructor(x, y, width, height, color) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.color = color;
          }

          draw() {
            ctx.fillStyle = this.color;
            const radius = 10;
            ctx.beginPath();
            ctx.moveTo(this.x + radius, this.y);
            ctx.lineTo(this.x + this.width - radius, this.y);
            ctx.quadraticCurveTo(this.x + this.width, this.y, this.x + this.width, this.y + radius);
            ctx.lineTo(this.x + this.width, this.y + this.height - radius);
            ctx.quadraticCurveTo(this.x + this.width, this.y + this.height, this.x + this.width - radius, this.y + this.height);
            ctx.lineTo(this.x + radius, this.y + this.height);
            ctx.quadraticCurveTo(this.x, this.y + this.height, this.x, this.y + this.height - radius);
            ctx.lineTo(this.x, this.y + radius);
            ctx.quadraticCurveTo(this.x, this.y, this.x + radius, this.y);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
          }
        }

        class Coin {
          constructor(x, y, radius, color) {
            this.x = x;
            this.y = y;
            this.radius = radius;
            this.color = color;
            this.rotation = 0;
          }

          draw() {
            this.rotation += 0.1;
            if (this.rotation >= Math.PI * 2) {
              this.rotation = 0;
            }
            const currentWidth = this.radius * (1 - 0.5 * Math.abs(Math.sin(this.rotation)));
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.ellipse(
              this.x - camera.x,
              this.y,
              currentWidth,
              this.radius,
              0,
              0,
              Math.PI * 2
            );
            ctx.closePath();
            ctx.fill();
          }
        }

        function getRandomColor() {
          const letters = '0123456789ABCDEF';
          let color = '#';
          for (let i = 0; i < 6; i++) {
            color += letters[Math.floor(Math.random() * 16)];
          }
          return color;
        }

        const platforms = [];

        function generatePlatforms() {
          if (platforms.length === 0 || platforms[platforms.length - 1].x - camera.x < canvas.width - 200) {
            const platformWidth = 200;
            const platformHeight = 20;
            const platformColor = getRandomColor();
            let minHeight = canvas.height / 2;
            let maxHeight = canvas.height - 150;
            const minGap = 50;
            const maxGap = 200;
            const randomGap = Math.floor(Math.random() * (maxGap - minGap + 1) + minGap);
            const xPos = platforms.length === 0 ? player.x + randomGap : platforms[platforms.length - 1].x + platformWidth + randomGap;

            let yPos;
            if (platforms.length === 0) {
              yPos = player.y;
            } else {
              const lastPlatformHeight = platforms[platforms.length - 1].y;
              const reachableMinHeight = Math.max(minHeight, lastPlatformHeight - player.jumpHeight * 2);
              const reachableMaxHeight = Math.min(maxHeight, lastPlatformHeight + player.jumpHeight * 2);
              yPos = Math.floor(Math.random() * (reachableMaxHeight - reachableMinHeight + 1) + reachableMinHeight);
            }

            platforms.push(new Platform(xPos, yPos, platformWidth, platformHeight, platformColor));

            if (platforms.length === 1) {
              setPlayerPositionOnPlatform(platforms[0]);
            }

            generateCoins();
          }
        }

        const coins = [];

        function generateCoins() {
          platforms.forEach((platform) => {
            if (!platform.coinsGenerated) {
              const numberOfCoins = Math.floor(Math.random() * 4) + 1;
              const coinSpacing = platform.width / (numberOfCoins + 1);
              for (let i = 0; i < numberOfCoins; i++) {
                const coinX = platform.x + coinSpacing * (i + 1);
                const coinY = platform.y - 25;
                coins.push(new Coin(coinX, coinY, 10, 'gold'));
              }
              platform.coinsGenerated = true;
            }
          });
        }

        function handlePlayerMovement() {
          player.x += player.speed;
          player.velocityX = player.speed;
          player.speed += 0.0000005;
        }

        function handlePlayerVerticalMovement() {
          player.velocityY += 0.5;
          player.y += player.velocityY;

          let onPlatform = false;
          const floorHeight = 50;
          if (player.y + player.height >= canvas.height - floorHeight) {
            onPlatform = true;
            player.y = canvas.height - player.height - floorHeight;
            player.velocityY = 0;
          }
          platforms.forEach((platform) => {
            if (
              player.x < platform.x + platform.width &&
              player.x + player.width > platform.x &&
              player.y + player.height >= platform.y - 5 &&
              player.y + player.height <= platform.y + platform.height
            ) {
              onPlatform = true;
              player.y = platform.y - player.height;
              player.velocityY = 0;
            }
          });

          player.isJumping = !onPlatform;
        }

        canvas.addEventListener('click', () => {
          if (!player.isJumping) {
            player.velocityY = -player.jumpHeight;
          }
        });

        canvas.addEventListener('touchstart', () => {
          if (!player.isJumping) {
            player.velocityY = -player.jumpHeight;
          }
        });

        function detectPlatformCollision() {
          const prevY = player.y - player.velocityY;

          let onPlatform = false;

          platforms.forEach((platform) => {
            if (
              player.x < platform.x + platform.width &&
              player.x + player.width > platform.x
            ) {
              if (
                prevY + player.height <= platform.y &&
                player.y + player.height >= platform.y &&
                player.velocityY >= 0
              ) {
                player.y = platform.y - player.height;
                player.velocityY = 0;
                onPlatform = true;
              } else if (
                prevY >= platform.y + platform.height &&
                player.y <= platform.y + platform.height
              ) {
                player.y = platform.y + platform.height;
                player.velocityY = 0;
              }
            }

            if (
              player.y + player.height > platform.y &&
              player.y < platform.y + platform.height
            ) {
              if (
                player.x + player.width >= platform.x &&
                player.x + player.width <= platform.x + 5
              ) {
                player.x = platform.x - player.width;
              } else if (
                player.x <= platform.x + platform.width &&
                player.x >= platform.x + platform.width - 5
              ) {
                player.x = platform.x + platform.width;
              }
            }
          });

          if (onPlatform) {
            player.isJumping = false;
          }
        }

        function detectCoinCollision() {
          coins.forEach((coin, index) => {
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;
            const distance = Math.sqrt((playerCenterX - coin.x) ** 2 + (playerCenterY - coin.y) ** 2);
            if (distance < player.width / 2 + coin.radius) {
              player.score += 1;
              coins.splice(index, 1);
            }
          });
        }

        function checkGroundCollision() {
          const floorHeight = 50;
          if (player.y + player.height > canvas.height - floorHeight) {
            player.y = canvas.height - player.height - floorHeight;
            player.velocityY = 0;
          }
        }

        function resetGame() {
          gameOver = false;
          player.x = 50;
          player.y = canvas.height - 150 - 50;
          player.velocityX = 0;
          player.velocityY = 0;
          player.score = 0;
          player.speed = 4;
          camera.x = 0;
          platforms.length = 0;
          coins.length = 0;
          generatePlatforms();
          player.explosionDrawn = false;
          player.explosionCounter = 0;
          backgroundMusic.currentTime = 0;
          backgroundMusic.play();
        }

        function loadHighScore() {
          const storedHighScore = localStorage.getItem('highScore');
          if (storedHighScore !== null) {
              highScore = parseInt(storedHighScore, 10);
          }
        }

        function updateHighScore() {
          if (player.score > highScore) {
              highScore = player.score;
              localStorage.setItem('highScore', highScore);
          }
        }

        window.addEventListener('load', loadHighScore);

        function update() {
          if (!gameOver) {
            handlePlayerVerticalMovement();
            detectPlatformCollision();
            checkGroundCollision();
            detectCoinCollision();

            handlePlayerMovement();
            generateCoins();

            camera.update();

            if (player.isJumping) {
              player.currentImage = characterImage1;
              animationFrame = 0;
            } else {
              animationFrame++;
              if (animationFrame % 20 < 10) {
                player.currentImage = characterImage1;
              } else {
                player.currentImage = characterImage2;
              }
            }

            generatePlatforms();
          }

          if (player.y + player.height >= canvas.height - 50) {
            gameOver = true;
            updateHighScore();
          }
        }

        function render() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawBackground();

          ctx.save();
          ctx.translate(-camera.x, 0);
          platforms.forEach((platform) => platform.draw());
          drawFloor();
          ctx.restore();
          coins.forEach((coin) => coin.draw());

          drawCharacter();
          drawScoreBox();
          drawHighScoreBox();
          drawGameOverAndReset();
        }

        function drawCharacter() {
          const characterHeight = player.height;
          const characterWidth = (characterImage1.width / characterImage1.height) * characterHeight;

          if (!gameOver) {
            ctx.save();
            ctx.translate(-camera.x, 0);

            if (player.velocityX < 0) {
              ctx.scale(-1, 1);
              ctx.drawImage(
                player.currentImage,
                -player.x - characterWidth + characterWidth,
                player.y,
                -characterWidth,
                characterHeight
              );
            } else {
              ctx.drawImage(
                player.currentImage,
                player.x,
                player.y,
                characterWidth,
                characterHeight
              );
            }

            ctx.restore();
          }

          if (gameOver && player.explosionCounter < 50) {
            const explosionWidth = characterWidth * 2;
            const explosionHeight = characterHeight * 2;

            ctx.save();
            ctx.translate(-camera.x, 0);
            ctx.drawImage(
              explosionImage,
              player.x - (explosionWidth - characterWidth) / 2,
              player.y - (explosionHeight - characterHeight) / 2,
              explosionWidth,
              explosionHeight
            );
            ctx.restore();

            player.explosionCounter++;
          }
        }

        function drawFloor() {
          const tileWidth = floorImage.width;
          const tileHeight = floorImage.height;
          const numTiles = Math.ceil(canvas.width / tileWidth) + 1;

          const startX = Math.floor(camera.x / tileWidth) * tileWidth;

          for (let i = 0; i < numTiles; i++) {
            ctx.drawImage(
              floorImage,
              startX + i * tileWidth,
              canvas.height - 50,
              tileWidth,
              tileHeight
            );
          }
        }

        function drawScoreBox() {
          drawRoundedRect(5, 5, 150, 35, 5, 'white', 'black', 3);
          ctx.fillStyle = 'black';
          ctx.font = '20px Arial';
          ctx.fillText(`Score: ${player.score}`, 10, 30);
        }

        function drawHighScoreBox() {
          drawRoundedRect(canvas.width - 185, 5, 180, 35, 5, 'white', 'black', 3);
          ctx.fillStyle = 'black';
          ctx.font = '20px Arial';
          ctx.fillText(`High Score: ${highScore}`, canvas.width - 180, 30);
        }

        function drawGameOverAndReset() {
          if (gameOver) {
            ctx.fillStyle = 'red';
            ctx.font = 'bold 60px Arial';
            ctx.fillText('Game Over', canvas.width / 2 - 150, canvas.height / 2 - 20);

            ctx.fillStyle = 'blue';
            const buttonWidth = 160;
            const buttonHeight = 60;
            const buttonX = canvas.width / 2 - buttonWidth / 2;
            const buttonY = canvas.height / 2 + 20;

            ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 30px Arial';
            ctx.fillText('Reset', buttonX + 40, buttonY + 40);
          }
        }

        function drawBackground() {
          const scale = canvas.height / backgroundImage.height;
          const scaledWidth = backgroundImage.width * scale;
          const numImages = Math.ceil(canvas.width / scaledWidth) + 1;

          let offsetX = (camera.x * 0.5) % scaledWidth;
          for (let i = 0; i < numImages; i++) {
            ctx.drawImage(backgroundImage, i * scaledWidth - offsetX, 0, scaledWidth, canvas.height);
          }
        }

        function drawRoundedRect(x, y, width, height, radius, fillColor, borderColor, borderWidth) {
          ctx.beginPath();
          ctx.moveTo(x + radius, y);
          ctx.lineTo(x + width - radius, y);
          ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
          ctx.lineTo(x + width, y + height - radius);
          ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
          ctx.lineTo(x + radius, y + height);
          ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
          ctx.lineTo(x, y + radius);
          ctx.quadraticCurveTo(x, y, x + radius, y);
          ctx.closePath();

          if (fillColor) {
            ctx.fillStyle = fillColor;
            ctx.fill();
          }

          if (borderColor && borderWidth) {
            ctx.lineWidth = borderWidth;
            ctx.strokeStyle = borderColor;
            ctx.stroke();
          }
        }

        function gameLoop() {
          update();
          render();
          requestAnimationFrame(gameLoop);
        }

        function startGame() {
            mainMenu.style.display = 'none';
            introVideo.style.display = 'none';
            canvas.style.display = 'block';
            backgroundMusic.currentTime = 0;
            backgroundMusic.play();
            resetGame();
        }

        async function lockOrientation() {
            if (screen.orientation && screen.orientation.lock) {
                try {
                    await screen.orientation.lock('landscape');
                } catch (error) {
                    console.error('Screen rotation could not be locked:', error);
                }
            }
        }

        startGameButton.addEventListener('click', async () => {
            await lockOrientation();
            introVideo.style.display = 'block';
            introVideo.play();
            introVideo.addEventListener('ended', startGame);
        });

        instructionsButton.addEventListener('click', () => {
            instructionBar.style.display = 'block';
        });

        exitButton.addEventListener('click', () => {
            exitMessage.style.display = 'block';
            });

        function closeInstructionBar() {
            instructionBar.style.display = 'none';
        }

        function closeExitBar() {
            exitBar.style.display = 'none';
        }

        canvas.addEventListener('click', (event) => {
          if (gameOver) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            const buttonX = canvas.width / 2 - 80;
            const buttonY = canvas.height / 2 + 20;
            const buttonWidth = 160;
            const buttonHeight = 60;

            if (
              x >= buttonX &&
              x <= buttonX + buttonWidth &&
              y >= buttonY &&
              y <= buttonY + buttonHeight
            ) {
              resetGame();
            }
          }
        });

        generatePlatforms();
        loadAssets(function() {
          gameLoop();
        });
    </script>
</body>
</html>
